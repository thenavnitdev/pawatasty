import "jsr:@supabase/functions-js/edge-runtime.d.ts";
import { createClient } from "npm:@supabase/supabase-js@2.57.4";

const corsHeaders = {
  "Access-Control-Allow-Origin": "*",
  "Access-Control-Allow-Methods": "GET, OPTIONS",
  "Access-Control-Allow-Headers": "Content-Type, Authorization, X-Client-Info, Apikey",
};

function parseCoverImageIds(coverImageIds: any): string[] {
  if (!coverImageIds) return [];
  try {
    return typeof coverImageIds === 'string' ? JSON.parse(coverImageIds) : coverImageIds;
  } catch (e) {
    console.error('Failed to parse cover_image_ids:', e);
    return [];
  }
}

function parseDealImageIds(imageIds: any): string[] {
  if (!imageIds) return [];
  try {
    return typeof imageIds === 'string' ? JSON.parse(imageIds) : imageIds;
  } catch (e) {
    console.error('Failed to parse deal image_ids:', e);
    return [];
  }
}

function formatMerchant(merchant: any, branch?: any, availableSlots?: number) {
  // If branch provided, use branch data for location-specific fields
  const isBranch = !!branch;
  const displayName = isBranch && branch.branch_name
    ? branch.branch_name
    : merchant.company_name;
  const displayAddress = isBranch && branch.address
    ? branch.address
    : merchant.address;
  const displayLat = isBranch && branch.latitude
    ? parseFloat(branch.latitude)
    : merchant.latitude;
  const displayLng = isBranch && branch.longitude
    ? parseFloat(branch.longitude)
    : merchant.longitude;

  return {
    id: isBranch ? `${merchant.merchant_id}_${branch.branch_id}` : merchant.merchant_id,
    merchantId: merchant.merchant_id,
    branchId: isBranch ? branch.branch_id : null,
    companyName: displayName,
    companyDescription: merchant.company_description,
    businessCategory: merchant.business_category,
    address: displayAddress,
    city: isBranch ? branch.city : merchant.city,
    latitude: displayLat,
    longitude: displayLng,
    phoneNr: isBranch && branch.phone_nr ? branch.phone_nr : merchant.phone_nr,
    website: merchant.website,
    openDays: isBranch && branch.open_days ? branch.open_days : merchant.open_days,
    openTime: isBranch && branch.open_time ? branch.open_time : merchant.open_time,
    logoId: merchant.logo_id || null,
    coverImageIds: parseCoverImageIds(isBranch && branch.cover_image_ids ? branch.cover_image_ids : merchant.cover_image_ids),
    rating: parseFloat(merchant.rating) || 0,
    distance: merchant.distance,
    isBranch: isBranch,
    availableSlots: availableSlots || 0,
    deals: merchant.merchant_deals?.map((deal: any) => {
      const imageIds = parseDealImageIds(deal.image_ids);
      const primaryImageId = imageIds.length > 0 ? imageIds[0] : (deal.image_id || null);

      return {
        id: deal.id,
        merchantId: merchant.merchant_id,
        title: deal.deal_name,
        description: deal.description,
        discount: parseInt(deal.discount_percentage) || 0,
        price: deal.price_value,
        saveValue: deal.save_value || 0,
        imageUrl: primaryImageId,
        imageIds: imageIds,
        bookable: deal.bookable,
        location: deal.location,
        repeatDays: deal.repeat_days,
      };
    }) || [],
  };
}

Deno.serve(async (req: Request) => {
  if (req.method === "OPTIONS") {
    return new Response(null, {
      status: 200,
      headers: corsHeaders,
    });
  }

  try {
    const supabase = createClient(
      Deno.env.get("SUPABASE_URL")!,
      Deno.env.get("SUPABASE_ANON_KEY")!,
    );

    const url = new URL(req.url);
    const pathParts = url.pathname.split("/").filter(Boolean);

    if (req.method === "GET" && pathParts.length === 2) {
      const merchantId = pathParts[1];

      const { data: merchant, error: merchantError } = await supabase
        .from("merchants")
        .select(`
          *,
          merchant_deals(
            id,
            deal_name,
            description,
            discount_percentage,
            price_value,
            save_value,
            image_id,
            image_ids,
            bookable,
            location,
            repeat_days
          )
        `)
        .eq("merchant_id", merchantId)
        .maybeSingle();

      if (merchantError) throw merchantError;
      if (!merchant) {
        return new Response(
          JSON.stringify({ error: "Merchant not found" }),
          {
            status: 404,
            headers: {
              ...corsHeaders,
              "Content-Type": "application/json",
            },
          },
        );
      }

      const { data: stationData } = await supabase
        .from("station_items")
        .select("available_slots")
        .eq("merchant_id", merchantId);

      const totalAvailableSlots = stationData?.reduce((sum, station) => sum + (station.available_slots || 0), 0) || 0;

      return new Response(JSON.stringify(formatMerchant(merchant, undefined, totalAvailableSlots)), {
        headers: {
          ...corsHeaders,
          "Content-Type": "application/json",
        },
      });
    }

    if (req.method === "GET" && pathParts.length === 1) {
      const lat = url.searchParams.get("lat");
      const lng = url.searchParams.get("lng");
      const radius = url.searchParams.get("radius") || "5000";

      let query = supabase
        .from("merchants")
        .select(`
          *,
          merchant_deals(
            id,
            deal_name,
            description,
            discount_percentage,
            price_value,
            save_value,
            image_id,
            image_ids,
            bookable,
            location,
            repeat_days
          )
        `);

      if (lat && lng) {
        const radiusMeters = parseInt(radius);
        query = query.rpc("merchants_within_radius", {
          lat: parseFloat(lat),
          lng: parseFloat(lng),
          radius_meters: radiusMeters,
        });
      }

      const { data: merchants, error: merchantsError } = await query;

      if (merchantsError) {
        console.error("Merchants query error:", merchantsError);
        throw merchantsError;
      }

      // Fetch all branches for these merchants
      const merchantIds = merchants.map(m => m.merchant_id);
      const { data: branches } = await supabase
        .from("merchant_branches")
        .select("*")
        .in("merchant_id", merchantIds)
        .not("latitude", "is", null)
        .not("longitude", "is", null);

      // Fetch available slots for all merchants
      const { data: stationData } = await supabase
        .from("station_items")
        .select("merchant_id, branch_id, available_slots")
        .in("merchant_id", merchantIds);

      // Create maps for available slots
      const merchantSlotsMap = new Map<string, number>(); // Slots at merchant level (no branch)
      const branchSlotsMap = new Map<string, number>(); // Slots at branch level
      const merchantHasBranchesMap = new Map<string, boolean>(); // Track if merchant has branch stations

      stationData?.forEach((station: any) => {
        if (station.branch_id) {
          // Branch station
          const branchKey = `${station.merchant_id}_${station.branch_id}`;
          const currentSlots = branchSlotsMap.get(branchKey) || 0;
          branchSlotsMap.set(branchKey, currentSlots + (station.available_slots || 0));
          merchantHasBranchesMap.set(station.merchant_id, true);
        } else {
          // Merchant-level station (no specific branch)
          const currentSlots = merchantSlotsMap.get(station.merchant_id) || 0;
          merchantSlotsMap.set(station.merchant_id, currentSlots + (station.available_slots || 0));
        }
      });

      // Create array of all locations (merchants + branches)
      const allLocations = [];

      // Add each merchant as a location only if:
      // 1. They have available slots at merchant level (not assigned to branches)
      // 2. OR they have no branches at all but have stations
      merchants.forEach(merchant => {
        const hasBranches = merchantHasBranchesMap.get(merchant.merchant_id);
        const merchantSlots = merchantSlotsMap.get(merchant.merchant_id) || 0;

        // Show merchant location if it has stations not assigned to any branch
        if (merchantSlots > 0) {
          allLocations.push(formatMerchant(merchant, undefined, merchantSlots));
        }
      });

      // Add each branch as a separate location (only if they have available power banks)
      if (branches && branches.length > 0) {
        branches.forEach(branch => {
          const parentMerchant = merchants.find(m => m.merchant_id === branch.merchant_id);
          if (parentMerchant) {
            const branchKey = `${branch.merchant_id}_${branch.branch_id}`;
            const availableSlots = branchSlotsMap.get(branchKey) || 0;
            if (availableSlots > 0) {
              allLocations.push(formatMerchant(parentMerchant, branch, availableSlots));
            }
          }
        });
      }

      return new Response(JSON.stringify(allLocations), {
        headers: {
          ...corsHeaders,
          "Content-Type": "application/json",
        },
      });
    }

    return new Response(
      JSON.stringify({ error: "Invalid request" }),
      {
        status: 400,
        headers: {
          ...corsHeaders,
          "Content-Type": "application/json",
        },
      },
    );
  } catch (error) {
    console.error("Error:", error);
    return new Response(
      JSON.stringify({ error: error.message || "Internal server error" }),
      {
        status: 500,
        headers: {
          ...corsHeaders,
          "Content-Type": "application/json",
        },
      },
    );
  }
});
